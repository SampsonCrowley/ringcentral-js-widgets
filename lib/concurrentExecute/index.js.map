{"version":3,"sources":["lib/concurrentExecute/index.js"],"names":["sleep","t","Promise","resolve","setTimeout","concurrentExecute","promiseThunks","concurrency","delay","options","promise","delayFn","Array","isArray","length","Error","all","map","_promise","apply","slice","current","rest"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAMA,KAAK,GAAG,SAARA,KAAQ,CAAAC,CAAC;AAAA,SAAI,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAa;AAC1CC,IAAAA,UAAU,CAAC;AAAA,aAAMD,OAAO,EAAb;AAAA,KAAD,EAAkBF,CAAlB,CAAV;AACD,GAFkB,CAAJ;AAAA,CAAf;AAIA;;;;;;;;;;SAQ8BI,iB;;;;;;;0BAAf,iBACbC,aADa,EAEbC,WAFa,EAGbC,KAHa;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAIbC,YAAAA,OAJa,2DAIH,EAJG;AAAA,+BAMkCA,OANlC,CAMLC,OANK,EAMLA,OANK,iCAMKR,OANL,wCAMkCO,OANlC,CAMcE,OANd,EAMcA,OANd,iCAMwBX,KANxB;;AAAA,kBAOT,CAACY,KAAK,CAACC,OAAN,CAAcP,aAAd,CAAD,IAAiCA,aAAa,CAACQ,MAAd,IAAwB,CAPhD;AAAA;AAAA;AAAA;;AAAA,6CAQJ,EARI;;AAAA;AAAA,kBAUT,OAAOR,aAAa,CAAC,CAAD,CAApB,KAA4B,UAVnB;AAAA;AAAA;AAAA;;AAAA,kBAWL,IAAIS,KAAJ,CAAU,uCAAV,CAXK;;AAAA;AAAA,kBAaTT,aAAa,CAACQ,MAAd,IAAwBP,WAbf;AAAA;AAAA;AAAA;;AAAA,6CAcJG,OAAO,CAACM,GAAR,CAAYV,aAAa,CAACW,GAAd,CAAkB,UAAAC,QAAQ;AAAA,qBAAIA,QAAQ,CAACC,KAAT,CAAe,KAAf,CAAJ;AAAA,aAA1B,CAAZ,CAdI;;AAAA;AAAA;AAAA,mBAgBSd,iBAAiB,CACrCC,aAAa,CAACc,KAAd,CAAoB,CAApB,EAAuBb,WAAvB,CADqC,EAErCA,WAFqC,EAGrCC,KAHqC,EAIrCC,OAJqC,CAhB1B;;AAAA;AAgBPY,YAAAA,OAhBO;;AAAA,iBAsBTb,KAtBS;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAuBLG,OAAO,CAACH,KAAD,CAvBF;;AAAA;AAAA;AAAA,mBAyBMH,iBAAiB,CAClCC,aAAa,CAACc,KAAd,CAAoBb,WAApB,CADkC,EAElCA,WAFkC,EAGlCC,KAHkC,EAIlCC,OAJkC,CAzBvB;;AAAA;AAyBPa,YAAAA,IAzBO;AAAA,0EA+BFD,OA/BE,sBA+BUC,IA/BV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["const sleep = t => new Promise((resolve) => {\n  setTimeout(() => resolve(), t);\n});\n\n/**\n * With concurrentExecute helper function, you could control\n * the concurrency and delay of your Promise.all execution.\n * @param {Array<Function>} promiseThunks A set of thunk functions of Promise\n * @param {Number} concurrency Concurrent granularity\n * @param {Number} delay Batch execution delay\n * @param {Function} delayFn Specify your own delay function\n */\nexport default async function concurrentExecute(\n  promiseThunks,\n  concurrency,\n  delay,\n  options = {}\n) {\n  const { promise = Promise, delayFn = sleep } = options;\n  if (!Array.isArray(promiseThunks) || promiseThunks.length <= 0) {\n    return [];\n  }\n  if (typeof promiseThunks[0] !== 'function') {\n    throw new Error('concurrentExecute needs promise thunk');\n  }\n  if (promiseThunks.length <= concurrency) {\n    return promise.all(promiseThunks.map(_promise => _promise.apply(this)));\n  }\n  const current = await concurrentExecute(\n    promiseThunks.slice(0, concurrency),\n    concurrency,\n    delay,\n    options\n  );\n  if (delay) {\n    await delayFn(delay);\n  }\n  const rest = await concurrentExecute(\n    promiseThunks.slice(concurrency),\n    concurrency,\n    delay,\n    options\n  );\n  return [...current, ...rest];\n}\n"],"file":"index.js"}