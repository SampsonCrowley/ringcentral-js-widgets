{"version":3,"sources":["modules/AvailabilityMonitor/index.js"],"names":["HEALTH_CHECK_INTERVAL","STATUS_END_POINT","AvailabilityMonitor","deps","dep","optional","alert","client","environment","enabled","options","actionTypes","_enabled","_alert","ensureExist","_client","_environment","_lastEnvironmentCounter","_healthRetryTime","_reducer","pending","ready","changeCounter","_shouldInit","store","dispatch","type","init","_bindHandlers","initSuccess","_shouldRebindHandlers","subscribe","_onStateChange","_unbindHandlers","service","platform","on","events","beforeRequest","params","_beforeRequestHandler","requestError","_requestErrorHandler","removeListener","isLimitedAvailabilityMode","requestUrl","requestMethod","url","method","Error","errorMessages","serviceLimited","error","retryAfter","_switchToLimitedAvailabilityMode","limitedMode","timeout","setTimeout","console","log","_intervalHealthCheck","normalMode","get","res","response","clearTimeout","_getStatus","status","waitingTime","_switchToNormalMode","errorLevel","message","success","warning","danger","info","_showAlert","appInitialError","state","isAppInitialError","RcModule"],"mappings":"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","sourcesContent":["/**\n * Created by Sophie, updated by Bruce\n */\n\nimport { pathOr } from 'ramda';\nimport { Module } from '../../lib/di';\nimport ensureExist from '../../lib/ensureExist';\nimport RcModule from '../../lib/RcModule';\nimport getAvailabilityModeReducer from './availabilityMonitorReducer';\nimport actionTypes from './actionTypes';\nimport { extractUrl, isHAError, generateRandomNumber, isHAEnabledAPI } from './availabilityMonitorHelper';\nimport errorMessages from './errorMessages';\n\n// Constants\nexport const HEALTH_CHECK_INTERVAL = 5 * 1000;\nexport const STATUS_END_POINT = '/restapi/v1.0/status';\n\n\n/**\n * TODO: Deal with `RateLimitor` in offline mode.\n * TODO: App initial errors.\n * TODO: When WebRTC met HA error.\n * TODO: Api match problems, the way finding *High* or *Limited* api is not working correctly.\n *\n * @class\n * @description Connectivity monitor module\n */\n@Module({\n  deps: [\n    'Alert',\n    'Client',\n    { dep: 'Environment', optional: true },\n    { dep: 'AvailabilityMonitorOptions', optional: true },\n  ],\n})\nexport default class AvailabilityMonitor extends RcModule {\n  /**\n   * @constructor\n   * @param {Object} params - params object\n   * @param {Alert} params.alert - alert module instance\n   * @param {Client} params.client - client module instance\n   * @param {Environment} params.environment - environment module instance\n   */\n  constructor({\n    alert,\n    client,\n    environment,\n    enabled = false,\n    ...options\n  }) {\n    super({\n      actionTypes,\n      enabled,\n      ...options,\n    });\n\n    this._enabled = enabled;\n    this._alert = this::ensureExist(alert, 'alert');\n    this._client = this::ensureExist(client, 'client');\n    this._environment = environment;\n    this._lastEnvironmentCounter = 0;\n    this._healthRetryTime = HEALTH_CHECK_INTERVAL;\n    this._reducer = getAvailabilityModeReducer(this.actionTypes);\n  }\n\n  _shouldInit() {\n    return !!(this.pending && (!this._environment || this._environment.ready));\n  }\n\n  _shouldRebindHandlers() {\n    return !!(\n      this.ready &&\n      this._environment &&\n      this._environment.ready &&\n      this._environment.changeCounter !== this._lastEnvironmentCounter\n    );\n  }\n\n  _onStateChange() {\n    if (this._shouldInit()) {\n      this.store.dispatch({\n        type: this.actionTypes.init,\n      });\n      this._bindHandlers();\n      this.store.dispatch({\n        type: this.actionTypes.initSuccess,\n      });\n    } else if (this._shouldRebindHandlers()) {\n      this._lastEnvironmentCounter = this._environment.changeCounter;\n      this._bindHandlers();\n    }\n  }\n\n  initialize() {\n    this.store.subscribe(() => this._onStateChange());\n  }\n\n  _bindHandlers() {\n    if (this._unbindHandlers) {\n      this._unbindHandlers();\n    }\n\n    const client = this._client.service.platform().client();\n    client.on(client.events.beforeRequest, (params) => {\n      this._beforeRequestHandler(params);\n    });\n\n    // !TODO: in other modules, when they catch error first check if app is in HA mode.\n    client.on(client.events.requestError, (params) => {\n      this._requestErrorHandler(params);\n    });\n\n    this._unbindHandlers = () => {\n      client.removeListener(\n        client.events.beforeRequest,\n        this._beforeRequestHandler,\n      );\n      client.removeListener(\n        client.events.requestError,\n        this._requestErrorHandler,\n      );\n      this._unbindHandlers = null;\n    };\n  }\n\n  _beforeRequestHandler(params) {\n    if (!this.isLimitedAvailabilityMode) {\n      return;\n    }\n\n    const requestUrl = pathOr(null, ['_request', 'url'], params);\n    const requestMethod = pathOr(null, ['_request', 'method'], params);\n\n    if (!requestUrl || !requestMethod) {\n      return;\n    }\n\n    // TODO: the `extractUrl` method might not work with some urls\n    // In the limited availability mode, should not block status check api\n    // or highly availability api.\n    if (extractUrl({ url: requestUrl }) === STATUS_END_POINT\n      || isHAEnabledAPI({ url: requestUrl, method: requestMethod })) {\n      return;\n    }\n\n    throw new Error(errorMessages.serviceLimited);\n  }\n\n  /**\n   * Check if app can enter LA mode.\n   * If this module is not enabled, just return.\n   *\n   * @param {*} error Http response\n   * @memberof AvailabilityMonitor\n   */\n  _requestErrorHandler(error) {\n    if (!isHAError(error) || !this._enabled) {\n      // TODO: Request url included in initial api when app is in initial. If true enter initial error.\n      return;\n    }\n\n    const retryAfter = pathOr(\n      -1,\n      ['apiResponse', '_response', 'headers', 'retryAfter'],\n      error,\n    );\n\n    if (retryAfter > 0) {\n      this._healthRetryTime = retryAfter;\n    }\n\n    this._switchToLimitedAvailabilityMode();\n  }\n\n  async _switchToLimitedAvailabilityMode() {\n    if (this.isLimitedAvailabilityMode) {\n      return;\n    }\n\n    this.store.dispatch({\n      type: this.actionTypes.limitedMode,\n    });\n\n    this.timeout = setTimeout(async () => {\n      console.log('this._healthRetryTime', this._healthRetryTime);\n      await this._intervalHealthCheck();\n    }, this._healthRetryTime);\n  }\n\n  _switchToNormalMode() {\n    console.log('swith to normal mode');\n\n    if (!this.isLimitedAvailabilityMode) {\n      return;\n    }\n\n    this.store.dispatch({\n      type: this.actionTypes.normalMode,\n    });\n  }\n\n  async _getStatus() {\n    const res = await this._client.service.platform().get('/status');\n    return res && res.response();\n  }\n\n  /**\n   * Keep retrying with different intervals\n   * @returns\n   * @memberof AvailabilityMonitor\n   */\n  async _intervalHealthCheck() {\n    console.log('should randomize the health check');\n\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n    }\n    const response = await this._getStatus();\n    const retryAfter = pathOr(-1, ['headers', 'retryAfter'], response);\n\n    console.log('response', response);\n\n    if (response && response.status === 200) {\n      console.log('platform recover');\n\n      const waitingTime = generateRandomNumber(); // Generate random seconds (0 ~ 3000)\n      setTimeout(() => {\n        this._switchToNormalMode();\n      }, waitingTime);\n\n      return;\n    } else if (retryAfter > 0) {\n      this._healthRetryTime = retryAfter;\n    } else {\n      this._healthRetryTime = HEALTH_CHECK_INTERVAL;\n    }\n    this.timeout = setTimeout(async () => {\n      await this._intervalHealthCheck();\n    }, this._healthRetryTime);\n  }\n\n  _showAlert(errorLevel, message) {\n    if (errorLevel === 'success') {\n      this._alert.success({ message });\n    } else if (errorLevel === 'warning') {\n      this._alert.warning({ message });\n    } else if (errorLevel === 'danger') {\n      this._alert.danger({ message });\n    } else if (errorLevel === 'info') {\n      this._alert.info({ message });\n    }\n  }\n\n  get status() {\n    return this.state.status;\n  }\n\n  /**\n   * Is App in limited mode\n   *\n   * @readonly\n   * @memberof AvailabilityMonitor\n   */\n  get isLimitedAvailabilityMode() {\n    return this.state.isLimitedAvailabilityMode;\n  }\n\n  get isAppInitialErrorMode() {\n    return this.state.isAppInitialError;\n  }\n\n  /**\n   * Handle app initial errors\n   *\n   * @param {*} error\n   * @returns\n   * @memberof AvailabilityMonitor\n   */\n  handleInitialError(error) {\n    if (isHAError(error) || !this._enabled) {\n      return;\n    }\n\n    this._showAlert('danger', errorMessages.appInitialError);\n    // TODO: Need corresponde action to switch APP state back to normal\n    // this.store.dispatch({\n    //   type: this.actionTypes.appInitialError,\n    // });\n  }\n}\n"],"file":"index.js"}