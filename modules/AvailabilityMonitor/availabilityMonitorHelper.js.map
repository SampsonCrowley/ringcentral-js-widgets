{"version":3,"sources":["modules/AvailabilityMonitor/availabilityMonitorHelper.js"],"names":["TMP_HA_ERROR_CODE","HA_ERROR_CODE","HA_ERROR_STATUS","extractUrl","url","filteredUrl","match","splitUrl","split","isHAError","error","status","errors","errorCodeIn","e","validHAError","resErrorCode","generateRandomNumber","Math","floor","random","getAvailabilityLevel","path","method","highAvailabilityAPI","api","reg","isHAEnabledAPI","condition","console","availability","HIGH"],"mappings":"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","sourcesContent":["/**\n * Created by Sophie, edited by Bruce\n */\nimport { pathOr } from 'ramda';\nimport highAvailabilityAPI from './highAvailabilityAPI';\nimport availability from './availabilityStatus';\n\nexport const TMP_HA_ERROR_CODE = 'MaintenanceMode';\nexport const HA_ERROR_CODE = 'CMN-211';\nexport const HA_ERROR_STATUS = 503;\n\nexport function extractUrl({ url }) {\n  const filteredUrl =\n    (url.match(/\\/restapi(.*)/gi) && url.match(/\\/restapi(.*)/gi)[0]) || '';\n  const splitUrl = filteredUrl.split('?')[0] || '';\n  return splitUrl;\n}\n\n/** Check if this damn error is HA error. */\nexport function isHAError(error) {\n  const status = pathOr(-1, ['apiResponse', '_response', 'status'], error);\n  const errors = pathOr([], ['apiResponse', '_json', 'errors'], error);\n\n  let errorCodeIn = false;\n  for (const e of errors) {\n    if (pathOr('', ['errorCode'], e) === HA_ERROR_CODE) {\n      errorCodeIn = true;\n      break;\n    }\n  }\n\n  // Result from `status` and `errorCode`.\n  let validHAError = (status === HA_ERROR_STATUS && errorCodeIn);\n  if (!validHAError) {\n    // Result from temp error code, expecially for `presence`.\n    const resErrorCode = pathOr(null, ['apiResponse', '_json', 'errorCode'], error);\n    validHAError = (resErrorCode === TMP_HA_ERROR_CODE);\n  }\n\n  return validHAError;\n}\n\n/**\n * Generate 0 ~ 3000 seconds\n *\n * @export\n * @returns 0 ~ 3000 seconds\n */\nexport function generateRandomNumber() {\n  return Math.floor(Math.random() * 3000);\n}\n\n/**\n * Get availability level by path of url\n * TODO: Use lru cache to improve performance?\n */\nfunction getAvailabilityLevel(path, method) {\n  for (const api of highAvailabilityAPI) {\n    if (path.match(api.reg) && method in api) {\n      return api[method];\n    }\n  }\n}\n\n/**\n * Check if an api is *High* or *Limited*\n *\n * @export\n * @param {*} { url, method }\n * @returns boolean\n */\nexport function isHAEnabledAPI({ url, method }) {\n  const filteredUrl = extractUrl({ url });\n  if (!filteredUrl) {\n    return false;\n  }\n\n  const condition = getAvailabilityLevel(filteredUrl, method);\n  if (!condition) {\n    console.error(\n      `url: ${url} method: ${method} is not set in high or limited available API`,\n    );\n    return false;\n  }\n\n  return (condition === availability.HIGH);\n}\n"],"file":"availabilityMonitorHelper.js"}