{"version":3,"sources":["modules/AvailabilityMonitor/index.js"],"names":["HEALTH_CHECK_INTERVAL","STATUS_END_POINT","AvailabilityMonitor","deps","dep","optional","alert","client","environment","enabled","options","actionTypes","_enabled","_alert","ensureExist","_client","_environment","_lastEnvironmentCounter","_healthRetryTime","_reducer","_beforeRequestHandler","_requestErrorHandler","pending","ready","changeCounter","_shouldInit","store","dispatch","type","init","_bindHandlers","initSuccess","_shouldRebindHandlers","subscribe","_onStateChange","_unbindHandlers","service","platform","on","events","beforeRequest","requestError","removeListener","params","isLimitedAvailabilityMode","requestUrl","requestMethod","url","method","Error","errorMessages","serviceLimited","error","showAlert","retryAfter","_switchToLimitedAvailabilityMode","limitedMode","_limitedTimeout","setTimeout","_intervalHealthCheck","normalMode","_clearTimeout","_normalTimeout","alertIds","messages","filter","m","message","map","id","length","dismiss","timeoutHandler","clearTimeout","get","res","response","_getStatus","status","waitingTime","_switchToNormalMode","warning","allowDuplicates","errMessage","state","moduleStatuses","mode","availabilityStatus","LIMITED","isAppInitialError","RcModule"],"mappings":"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","sourcesContent":["/**\n * Created by Sophie, updated by Bruce\n */\nimport { pathOr } from 'ramda';\nimport { Module } from '../../lib/di';\nimport moduleStatuses from '../../enums/moduleStatuses';\nimport ensureExist from '../../lib/ensureExist';\nimport RcModule from '../../lib/RcModule';\nimport getAvailabilityModeReducer from './availabilityMonitorReducer';\nimport actionTypes from './actionTypes';\nimport availabilityStatus from './availabilityStatus';\nimport {\n  extractUrl,\n  isHAError,\n  generateRandomNumber,\n  isHAEnabledAPI,\n} from './availabilityMonitorHelper';\nimport errorMessages from './errorMessages';\n\n// Constants\nexport const HEALTH_CHECK_INTERVAL = 60 * 1000;\nexport const STATUS_END_POINT = '/restapi/v1.0/status';\n\n/**\n * @class AvailabilityMonitor\n * @description Connectivity monitor module\n */\n@Module({\n  deps: [\n    'Alert',\n    'Client',\n    { dep: 'Environment', optional: true },\n    { dep: 'AvailabilityMonitorOptions', optional: true },\n  ],\n})\nexport default class AvailabilityMonitor extends RcModule {\n  /**\n   * @constructor\n   * @param {Object} params - params object\n   * @param {Alert} params.alert - alert module instance\n   * @param {Client} params.client - client module instance\n   * @param {Environment} params.environment - environment module instance\n   */\n  constructor({ alert, client, environment, enabled = false, ...options }) {\n    super({\n      actionTypes,\n      enabled,\n      ...options,\n    });\n\n    this._enabled = enabled;\n    this._alert = this::ensureExist(alert, 'alert');\n    this._client = this::ensureExist(client, 'client');\n    this._environment = environment;\n    this._lastEnvironmentCounter = 0;\n    this._healthRetryTime = HEALTH_CHECK_INTERVAL;\n    this._reducer = getAvailabilityModeReducer(this.actionTypes);\n\n    // auto bind this\n    this._beforeRequestHandler = this::this._beforeRequestHandler;\n    this._requestErrorHandler = this::this._requestErrorHandler;\n  }\n\n  _shouldInit() {\n    return !!(this.pending &&\n      (!this._environment || this._environment.ready));\n  }\n\n  _shouldRebindHandlers() {\n    return !!(\n      this.ready &&\n      this._environment &&\n      this._environment.ready &&\n      this._environment.changeCounter !== this._lastEnvironmentCounter\n    );\n  }\n\n  _onStateChange() {\n    if (this._shouldInit()) {\n      this.store.dispatch({\n        type: this.actionTypes.init,\n      });\n      this._bindHandlers();\n      this.store.dispatch({\n        type: this.actionTypes.initSuccess,\n      });\n    } else if (this._shouldRebindHandlers()) {\n      this._lastEnvironmentCounter = this._environment.changeCounter;\n      this._bindHandlers();\n    }\n  }\n\n  initialize() {\n    this.store.subscribe(() => this._onStateChange());\n  }\n\n  _bindHandlers() {\n    if (this._unbindHandlers) {\n      this._unbindHandlers();\n    }\n\n    const client = this._client.service.platform().client();\n    client.on(client.events.beforeRequest, this._beforeRequestHandler);\n\n    // TODO: in other modules, when they catch error first check if app is in HA mode.\n    client.on(client.events.requestError, this._requestErrorHandler);\n\n    this._unbindHandlers = () => {\n      client.removeListener(client.events.beforeRequest, this._beforeRequestHandler);\n      client.removeListener(client.events.requestError, this._requestErrorHandler);\n      this._unbindHandlers = null;\n    };\n  }\n\n  _beforeRequestHandler(params) {\n    if (!this.isLimitedAvailabilityMode || !this._enabled) {\n      return;\n    }\n\n    const requestUrl = pathOr(null, ['_request', 'url'], params);\n    const requestMethod = pathOr(null, ['_request', 'method'], params);\n\n    if (!requestUrl || !requestMethod) {\n      return;\n    }\n\n    // In the limited availability mode, should not block status check api\n    // or highly availability api.\n    if (\n      extractUrl({ url: requestUrl }) === STATUS_END_POINT ||\n      isHAEnabledAPI({ url: requestUrl, method: requestMethod })\n    ) {\n      return;\n    }\n\n    throw new Error(errorMessages.serviceLimited);\n  }\n\n  /**\n   * Check if app can enter LA mode.\n   * If this module is not enabled, just return.\n   *\n   * @param {*} error Http response\n   * @memberof AvailabilityMonitor\n   */\n  _requestErrorHandler(error) {\n    if (!isHAError(error) || !this._enabled) {\n      // TODO: Request url included in initial api when app is in initial. If true enter initial error.\n      return;\n    }\n\n    this.showAlert(errorMessages.serviceLimited);\n\n    const retryAfter = pathOr(\n      -1,\n      ['apiResponse', '_response', 'headers', 'retryAfter'],\n      error,\n    );\n\n    if (retryAfter > 0) {\n      this._healthRetryTime = retryAfter;\n    }\n\n    this._switchToLimitedAvailabilityMode();\n  }\n\n  async _switchToLimitedAvailabilityMode() {\n    if (this.isLimitedAvailabilityMode) {\n      return;\n    }\n\n    this.store.dispatch({\n      type: this.actionTypes.limitedMode,\n    });\n\n    this._limitedTimeout = setTimeout(async () => {\n      await this._intervalHealthCheck();\n    }, this._healthRetryTime);\n  }\n\n  _switchToNormalMode() {\n    if (!this.isLimitedAvailabilityMode) {\n      return;\n    }\n\n    this.store.dispatch({\n      type: this.actionTypes.normalMode,\n    });\n\n    this._clearTimeout(this._normalTimeout);\n    this._clearTimeout(this._limitedTimeout);\n\n    if (!this._alert) {\n      return;\n    }\n    // dismiss disconnected alerts if found\n    const alertIds = this._alert.messages\n      .filter((m) => m.message === errorMessages.serviceLimited) // eslint-disable-line arrow-parens\n      .map((m) => m.id); // eslint-disable-line arrow-parens\n    if (alertIds.length) {\n      this._alert.dismiss(alertIds);\n    }\n  }\n\n  /**\n   * Clear timeout handler when it's not needed\n   */\n  _clearTimeout(timeoutHandler) {\n    if (!timeoutHandler) {\n      return;\n    }\n\n    clearTimeout(timeoutHandler);\n    timeoutHandler = null;\n  }\n\n  async _getStatus() {\n    const res = await this._client.service.platform().get('/status');\n    return res && res.response();\n  }\n\n  /**\n   * Keep retrying with different intervals\n   * @returns\n   * @memberof AvailabilityMonitor\n   */\n  async _intervalHealthCheck() {\n    this._clearTimeout(this._limitedTimeout);\n\n    const response = await this._getStatus();\n    const retryAfter = pathOr(0, ['headers', 'retryAfter'], response);\n\n    if (response && response.status === 200) {\n      const waitingTime = generateRandomNumber(); // Generate random seconds (0 ~ 3000)\n      this._normalTimeout = setTimeout(() => {\n        this._switchToNormalMode();\n      }, waitingTime);\n\n      return;\n    }\n\n    if (retryAfter > 0) {\n      this._healthRetryTime = retryAfter;\n    } else {\n      this._healthRetryTime = HEALTH_CHECK_INTERVAL;\n    }\n\n    this._limitedTimeout = setTimeout(async () => {\n      await this._intervalHealthCheck();\n    }, this._healthRetryTime);\n  }\n\n  showAlert(message) {\n    if (!this._alert) {\n      return;\n    }\n\n    this._alert.warning({\n      message,\n      allowDuplicates: false,\n    });\n  }\n\n  /**\n   * Check if the error is Survival Mode error,\n   * Or if app is already in Survival Mode and current request is blocked with an error.\n   */\n  checkIfHAError(error) {\n    const errMessage = pathOr(null, ['message'], error);\n    return isHAError(error) || errMessage === errorMessages.serviceLimited;\n  }\n\n  get status() {\n    return this.state.status;\n  }\n\n  get ready() {\n    return this.state.status === moduleStatuses.ready;\n  }\n\n  get pending() {\n    return this.state.status === moduleStatuses.pending;\n  }\n\n  /**\n   * Is App in limited mode\n   *\n   * @readonly\n   * @memberof AvailabilityMonitor\n   */\n  get isLimitedAvailabilityMode() {\n    return (\n      this.state.isLimitedAvailabilityMode.mode === availabilityStatus.LIMITED\n    );\n  }\n\n  get isAppInitialErrorMode() {\n    return this.state.isAppInitialError;\n  }\n}\n"],"file":"index.js"}