{"version":3,"sources":["lib/parseLocaleFile/index.js"],"names":["parseLocaleFile","rawContent","data","content","annotations","ast","sourceType","defaultExport","item","type","program","body","declaration","prop","key","substring","start","end","value","eval","code","source","get","set","properties"],"mappings":";;;;;;;;;;kBAMwBA,e;;AANxB;;AACA;;AACA;;;;AACA;;;;;;AAEA;AACe,SAASA,eAAT,CAAyBC,UAAzB,EAAqC;AAClD,MAAMC,OAAO,mBAAb;;AADkD,4BAEjB,kCAAmBD,UAAnB,CAFiB;AAAA,MAE1CE,OAF0C,uBAE1CA,OAF0C;AAAA,MAEjCC,WAFiC,uBAEjCA,WAFiC;;AAGlD,MAAMC,MAAM,oBAAMF,OAAN,EAAe,EAAEG,YAAY,QAAd,EAAf,CAAZ;;AAEA,MAAMC,gBAAgB,iBACpB;AAAA,WAAQC,KAAKC,IAAL,KAAc,0BAAtB;AAAA,GADoB,EAEpBJ,IAAIK,OAAJ,CAAYC,IAFQ,CAAtB;AAIA,MAAIJ,iBAAiBA,cAAcK,WAAd,CAA0BH,IAA1B,KAAmC,kBAAxD,EAA4E;AAC1E,wBAAQ,UAACI,IAAD,EAAU;AAChB;AACA,UAAIC,MAAMX,QAAQY,SAAR,CAAkBF,KAAKC,GAAL,CAASE,KAA3B,EAAkCH,KAAKC,GAAL,CAASG,GAA3C,CAAV;AACA;AACA,UACEJ,KAAKC,GAAL,CAASL,IAAT,KAAkB,eAAlB,IACAI,KAAKC,GAAL,CAASL,IAAT,KAAkB,YADlB,IAEAI,KAAKC,GAAL,CAASL,IAAT,KAAkB,gBAHpB,EAIE;AACAK,oBAAUA,GAAV;AACD;AACD;AACA,UAAMI,QAAQC,KAAK,8BAASN,KAAKK,KAAd,EAAqBE,IAA1B,CAAd;AACA,UAAMC,SAASjB,YAAYkB,GAAZ,CAAgBR,GAAhB,CAAf;;AAEAZ,WAAKqB,GAAL,CACET,GADF,EAEE;AACEA,gBADF;AAEEI,oBAFF;AAGEG;AAHF,OAFF;AAQD,KAvBD,EAuBGd,cAAcK,WAAd,CAA0BY,UAvB7B;AAwBD;;AAED,SAAO;AACLrB,oBADK;AAELC,4BAFK;AAGLC,YAHK;AAILH;AAJK,GAAP;AAMD","file":"index.js","sourcesContent":["import { parse } from 'babylon';\nimport { find, forEach } from 'ramda';\nimport generate from 'babel-generator';\nimport extractAnnotations from '../extractAnnotations';\n\n/* eslint { no-eval: 0 } */\nexport default function parseLocaleFile(rawContent) {\n  const data = new Map();\n  const { content, annotations } = extractAnnotations(rawContent);\n  const ast = parse(content, { sourceType: 'module' });\n\n  const defaultExport = find(\n    item => item.type === 'ExportDefaultDeclaration',\n    ast.program.body,\n  );\n  if (defaultExport && defaultExport.declaration.type === 'ObjectExpression') {\n    forEach((prop) => {\n      // get raw key from source content\n      let key = content.substring(prop.key.start, prop.key.end);\n      // wrap key in [] if needed\n      if (\n        prop.key.type !== 'StringLiteral' &&\n        prop.key.type !== 'Identifier' &&\n        prop.key.type !== 'NumericLiteral'\n      ) {\n        key = `[${key}]`;\n      }\n      // evaluate value to convert template literals or string concats into single string literal\n      const value = eval(generate(prop.value).code);\n      const source = annotations.get(key);\n\n      data.set(\n        key,\n        {\n          key,\n          value,\n          source\n        }\n      );\n    }, defaultExport.declaration.properties);\n  }\n\n  return {\n    content,\n    annotations,\n    ast,\n    data,\n  };\n}\n"]}